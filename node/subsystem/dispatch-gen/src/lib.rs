// Copyright 2021 Parity Technologies (UK) Ltd.
// This file is part of Polkadot.

// Polkadot is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Polkadot is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Polkadot.  If not, see <http://www.gnu.org/licenses/>.

use proc_macro2::TokenStream;
use quote::{quote, ToTokens};
use syn::{parse2, Error, Fields, FieldsNamed, FieldsUnnamed, Ident, ItemEnum, Path, Result, Type, Variant};
use std::fmt;

#[proc_macro_attribute]
pub fn subsystem_dispatch_gen(attr: proc_macro::TokenStream, item: proc_macro::TokenStream) -> proc_macro::TokenStream {
	let attr = proc_macro2::TokenStream::from(attr);
	let item = proc_macro2::TokenStream::from(item);
	proc_macro::TokenStream::from(subsystem_dispatch_gen2(attr, item))
}

/// An enum variant without base type.
#[derive(Clone)]
struct EnumVariantDispatchWithTy {
	// enum ty name
	ty: Ident,
	// variant
	variant: EnumVariantDispatch,
}

impl fmt::Debug for EnumVariantDispatchWithTy {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		write!(f, "{}::{:?}", self.ty, self.variant)
	}
}

impl ToTokens for EnumVariantDispatchWithTy {
	fn to_tokens(&self, tokens: &mut proc_macro2::TokenStream) {
		if let Some(inner) = &self.variant.inner {
			let enum_name = &self.ty;
			let variant_name = &self.variant.name;

			let ts = quote! {
				#enum_name::#variant_name(#inner::from(event))
			};

			tokens.extend(std::iter::once(ts));
		}
	}
}

/// An enum variant without the base type, contains the relevant inner type.
#[derive(Clone)]
struct EnumVariantDispatch {
	// variant name
	name: Ident,
	// inner type, if any, `None` if skipped
	// TODO make this a TokenStream and only accept verbatim
	inner: Option<Type>,
}

impl fmt::Debug for EnumVariantDispatch {
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		write!(f, "{}(..)", self.name)
	}
}

fn prepare_enum_variant(variant: &mut Variant) -> Result<EnumVariantDispatch> {
	let skip = variant.attrs.iter().find(|attr| attr.path.is_ident("skip")).is_some();
	variant.attrs = variant.attrs.iter().filter(|attr| { !attr.path.is_ident("skip") }).cloned().collect::<Vec<_>>();

	let variant = variant.clone();
	let inner =
		match variant.fields.clone() {
			// look for one called inner
			Fields::Named(FieldsNamed { brace_token: _, named }) if !skip => named
				.iter()
				.filter(|field| {
					if let Some(ident) = &field.ident {
						ident.to_string() == "inner".to_owned()
					} else {
						false
					}
				})
				.map(|field| Some(field.ty.clone()))
				.next()
				.unwrap(),
				// .ok_or_else(|| input.error("Missing field named `inner`"))?,

			// take the first one
			Fields::Unnamed(FieldsUnnamed { paren_token: _, unnamed }) if !skip => unnamed
				.first()
				.map(|field| Some(field.ty.clone())).unwrap(),
				// .ok_or_else(|| input.error("Must at least have one inner type or be skipped"))?,
			_ if skip => None,
			_ => {
				// return Err(
				// 	input.error("Enum variant has either not skip and doesn't match anything, or somethin worse")
				// )
				unreachable!("fooo")
			}
		};

	Ok(EnumVariantDispatch { name: variant.ident, inner })
}

fn impl_subsystem_dispatch_gen2(attr: TokenStream, item: TokenStream) -> Result<proc_macro2::TokenStream> {
	let event_ty = parse2::<Path>(attr)?;

	let mut ie = parse2::<ItemEnum>(item)?;

	let message_enum = ie.ident.clone();
	let variants = ie.variants.iter_mut()
		.try_fold(Vec::<EnumVariantDispatchWithTy>::new(), |mut acc, variant| {
			let variant = prepare_enum_variant(variant)?;
			if variant.inner.is_some() {
				acc.push(EnumVariantDispatchWithTy { ty: message_enum.clone(), variant })
			}
			Ok::<_, syn::Error>(acc)
		})?;

	let mut orig = ie.to_token_stream();

	let msg = "Generated by #[subsystem_dispatch_gen] proc-macro.";

	orig.extend(quote! {
		impl #message_enum {
			#[doc = #msg]
			pub fn dispatch_iter(event: #event_ty) -> impl Iterator<Item=Self> + Send {

				let mut iter = None.into_iter();

				#(
				let mut iter = iter.chain(std::iter::once(event.focus().ok().map(|event| {
						#variants
					})));

				)*
				iter.filter_map(|x| x)
			}
		}
	});
	Ok(orig)
}

fn subsystem_dispatch_gen2(attr: proc_macro2::TokenStream, item: proc_macro2::TokenStream) -> proc_macro2::TokenStream {
	impl_subsystem_dispatch_gen2(attr, item).unwrap_or_else(|err| err.to_compile_error()).into()
}

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn pass() {
		let attr = quote! {
			NetEvent<foo::Bar>
		};

		let item = quote! {
			/// Documentation.
			#[derive(Clone)]
			enum AllMessages {

				Sub1(Inner1),

				#[skip]
				/// D3
				Sub3,

				/// D4
				#[skip]
				Sub4(Inner2),

				/// D2
				Sub2(Inner2),
			}
		};

		let output = impl_subsystem_dispatch_gen2(attr, item).unwrap();
		println!("//generated:");
		println!("{}", output);
	}
}
